{"version":3,"sources":["../../src/constants.ts","../../src/Element.tsx","../../src/Filter.ts","../../src/StyleFilter.ts","../../src/Parser.ts","../../src/Markup.tsx","../../src/Interweave.tsx","../node_modules/escape-html/index.js"],"names":["tagConfigs","a","content","TYPE_FLOW","self","type","address","invalid","audio","children","br","void","body","button","caption","parent","col","colgroup","details","dd","dl","dt","figcaption","footer","header","hr","img","li","main","ol","picture","rb","rp","rt","rtc","ruby","source","summary","table","tbody","td","tfoot","th","thead","tr","track","ul","video","wbr","tagName","createConfigBuilder","TAGS","Object","BANNED_TAG_LIST","ALLOWED_TAG_LIST","tag","FILTER_DENY","FILTER_CAST_NUMBER","FILTER_CAST_BOOL","FILTER_NO_CAST","ATTRIBUTES","alt","cite","class","colspan","controls","datetime","default","disabled","dir","height","href","id","kind","label","lang","loading","loop","media","muted","poster","rel","role","rowspan","scope","sizes","span","start","style","src","srclang","srcset","target","title","width","ATTRIBUTES_TO_PROPS","attributes","selfClose","Tag","className","name","key","String","value","ALLOWED_ATTRS","OPEN_TOKEN","allowed","banned","blocked","matchers","keyIndex","constructor","props","applyAttributeFilters","parentConfig","canRenderChild","match","elements","tokenizedString","elementIndex","matcher","matchedString","childConfig","nextMarkup","markup","allowAttributes","newValue","newName","extractStyleAttribute","filter","Array","getTagConfig","isSafe","node","mergedText","elementProps","applyMatchers","nodes","text","endIndex","length","mainContent","noWrap","disableFilters","onBeforeParse","afterCallbacks","allMatchers","beforeCallbacks","parser","isArray","matchHtmlRegExp","module","exports","string","escape","str","exec","html","index","lastIndex","charCodeAt","substring"],"mappings":"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","file":"static/js/5.c4a6128c.chunk.js","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\nimport React from 'react';\n/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\n\nconst TYPE_FLOW = 1;\nconst TYPE_SECTION = 1 << 1;\nconst TYPE_HEADING = 1 << 2;\nconst TYPE_PHRASING = 1 << 3;\nconst TYPE_EMBEDDED = 1 << 4;\nconst TYPE_INTERACTIVE = 1 << 5;\nconst TYPE_PALPABLE = 1 << 6; // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n\nconst tagConfigs = {\n  a: {\n    content: TYPE_FLOW | TYPE_PHRASING,\n    self: false,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  address: {\n    invalid: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'address', 'article', 'aside', 'section', 'div', 'header', 'footer'],\n    self: false\n  },\n  audio: {\n    children: ['track', 'source']\n  },\n  br: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  },\n  body: {\n    content: TYPE_FLOW | TYPE_SECTION | TYPE_HEADING | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  button: {\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  caption: {\n    content: TYPE_FLOW,\n    parent: ['table']\n  },\n  col: {\n    parent: ['colgroup'],\n    void: true\n  },\n  colgroup: {\n    children: ['col'],\n    parent: ['table']\n  },\n  details: {\n    children: ['summary'],\n    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  dd: {\n    content: TYPE_FLOW,\n    parent: ['dl']\n  },\n  dl: {\n    children: ['dt', 'dd'],\n    type: TYPE_FLOW\n  },\n  dt: {\n    content: TYPE_FLOW,\n    invalid: ['footer', 'header'],\n    parent: ['dl']\n  },\n  figcaption: {\n    content: TYPE_FLOW,\n    parent: ['figure']\n  },\n  footer: {\n    invalid: ['footer', 'header']\n  },\n  header: {\n    invalid: ['footer', 'header']\n  },\n  hr: {\n    type: TYPE_FLOW,\n    void: true\n  },\n  img: {\n    void: true\n  },\n  li: {\n    content: TYPE_FLOW,\n    parent: ['ul', 'ol', 'menu']\n  },\n  main: {\n    self: false\n  },\n  ol: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  picture: {\n    children: ['source', 'img'],\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED\n  },\n  rb: {\n    parent: ['ruby', 'rtc']\n  },\n  rp: {\n    parent: ['ruby', 'rtc']\n  },\n  rt: {\n    content: TYPE_PHRASING,\n    parent: ['ruby', 'rtc']\n  },\n  rtc: {\n    content: TYPE_PHRASING,\n    parent: ['ruby']\n  },\n  ruby: {\n    children: ['rb', 'rp', 'rt', 'rtc']\n  },\n  source: {\n    parent: ['audio', 'video', 'picture'],\n    void: true\n  },\n  summary: {\n    content: TYPE_PHRASING,\n    parent: ['details']\n  },\n  table: {\n    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n    type: TYPE_FLOW\n  },\n  tbody: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  td: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  tfoot: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  th: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  thead: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  tr: {\n    parent: ['table', 'tbody', 'thead', 'tfoot'],\n    children: ['th', 'td']\n  },\n  track: {\n    parent: ['audio', 'video'],\n    void: true\n  },\n  ul: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  video: {\n    children: ['track', 'source']\n  },\n  wbr: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  }\n};\n\nfunction createConfigBuilder(config) {\n  return tagName => {\n    tagConfigs[tagName] = { ...config,\n      ...tagConfigs[tagName]\n    };\n  };\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['abbr', 'b', 'bdi', 'bdo', 'cite', 'code', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'ruby', 'samp', 'strong', 'sub', 'sup', 'time', 'u', 'var'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE\n}));\n['p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['s', 'small', 'span', 'del', 'ins'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING\n}));\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE\n}));\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE\n}));\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(createConfigBuilder({\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE\n})); // Disable this map from being modified\n\nconst TAGS = Object.freeze(tagConfigs); // Tags that should never be allowed, even if the allow list is disabled\n\nconst BANNED_TAG_LIST = ['applet', 'base', 'body', 'command', 'embed', 'frame', 'frameset', 'head', 'html', 'link', 'meta', 'noscript', 'object', 'script', 'style', 'title'];\nconst ALLOWED_TAG_LIST = Object.keys(TAGS).filter(tag => tag !== 'canvas' && tag !== 'iframe'); // Filters apply to HTML attributes\n\nconst FILTER_ALLOW = 1;\nconst FILTER_DENY = 2;\nconst FILTER_CAST_NUMBER = 3;\nconst FILTER_CAST_BOOL = 4;\nconst FILTER_NO_CAST = 5; // Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n\nconst ATTRIBUTES = Object.freeze({\n  alt: FILTER_ALLOW,\n  cite: FILTER_ALLOW,\n  class: FILTER_ALLOW,\n  colspan: FILTER_CAST_NUMBER,\n  controls: FILTER_CAST_BOOL,\n  datetime: FILTER_ALLOW,\n  default: FILTER_CAST_BOOL,\n  disabled: FILTER_CAST_BOOL,\n  dir: FILTER_ALLOW,\n  height: FILTER_ALLOW,\n  href: FILTER_ALLOW,\n  id: FILTER_ALLOW,\n  kind: FILTER_ALLOW,\n  label: FILTER_ALLOW,\n  lang: FILTER_ALLOW,\n  loading: FILTER_ALLOW,\n  loop: FILTER_CAST_BOOL,\n  media: FILTER_ALLOW,\n  muted: FILTER_CAST_BOOL,\n  poster: FILTER_ALLOW,\n  rel: FILTER_ALLOW,\n  role: FILTER_ALLOW,\n  rowspan: FILTER_CAST_NUMBER,\n  scope: FILTER_ALLOW,\n  sizes: FILTER_ALLOW,\n  span: FILTER_CAST_NUMBER,\n  start: FILTER_CAST_NUMBER,\n  style: FILTER_NO_CAST,\n  src: FILTER_ALLOW,\n  srclang: FILTER_ALLOW,\n  srcset: FILTER_ALLOW,\n  target: FILTER_ALLOW,\n  title: FILTER_ALLOW,\n  type: FILTER_ALLOW,\n  width: FILTER_ALLOW\n}); // Attributes to camel case for React props\n\nconst ATTRIBUTES_TO_PROPS = Object.freeze({\n  class: 'className',\n  colspan: 'colSpan',\n  datetime: 'dateTime',\n  rowspan: 'rowSpan',\n  srclang: 'srcLang',\n  srcset: 'srcSet'\n});\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction Element({\n  attributes = {},\n  className,\n  children = null,\n  selfClose = false,\n  tagName\n}) {\n  const Tag = tagName;\n  return selfClose ? /*#__PURE__*/React.createElement(Tag, _extends({\n    className: className\n  }, attributes)) : /*#__PURE__*/React.createElement(Tag, _extends({\n    className: className\n  }, attributes), children);\n}\n\nclass Filter {\n  /**\n   * Filter and clean an HTML attribute value.\n   */\n  attribute(name, value) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return value;\n  }\n  /**\n   * Filter and clean an HTML node.\n   */\n\n\n  node(name, node) {\n    return node;\n  }\n\n}\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\n\n\nfunction match(string, pattern, process, isVoid = false) {\n  const matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n  if (!matches) {\n    return null;\n  }\n\n  return {\n    match: matches[0],\n    void: isVoid,\n    ...process(matches),\n    index: matches.index,\n    length: matches[0].length,\n    valid: true\n  };\n}\n\nclass Matcher {\n  constructor(name, options, factory) {\n    _defineProperty(this, \"greedy\", false);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"propName\", void 0);\n\n    _defineProperty(this, \"inverseName\", void 0);\n\n    _defineProperty(this, \"factory\", void 0);\n\n    if (process.env.NODE_ENV !== \"production\" && (!name || name.toLowerCase() === 'html')) {\n      throw new Error(`The matcher name \"${name}\" is not allowed.`);\n    } // @ts-expect-error Allow override\n\n\n    this.options = { ...options\n    };\n    this.propName = name;\n    this.inverseName = `no${name.charAt(0).toUpperCase() + name.slice(1)}`;\n    this.factory = factory !== null && factory !== void 0 ? factory : null;\n  }\n  /**\n   * Attempts to create a React element using a custom user provided factory,\n   * or the default matcher factory.\n   */\n\n\n  createElement(children, props) {\n    const element = this.factory ? /*#__PURE__*/React.createElement(this.factory, props, children) : this.replaceWith(children, props);\n\n    if (process.env.NODE_ENV !== \"production\" && typeof element !== 'string' && ! /*#__PURE__*/React.isValidElement(element)) {\n      throw new Error(`Invalid React element created from ${this.constructor.name}.`);\n    }\n\n    return element;\n  }\n  /**\n   * Trigger the actual pattern match and package the matched\n   * response through a callback.\n   */\n\n\n  doMatch(string, pattern, callback, isVoid = false) {\n    return match(string, pattern, callback, isVoid);\n  }\n  /**\n   * Callback triggered before parsing.\n   */\n\n\n  onBeforeParse(content, props) {\n    return content;\n  }\n  /**\n   * Callback triggered after parsing.\n   */\n\n\n  onAfterParse(content, props) {\n    return content;\n  }\n  /**\n   * Replace the match with a React element based on the matched token and optional props.\n   */\n\n\n}\n\nexport { ALLOWED_TAG_LIST as A, BANNED_TAG_LIST as B, Element as E, Filter as F, Matcher as M, TAGS as T, _extends as _, ATTRIBUTES as a, FILTER_DENY as b, ATTRIBUTES_TO_PROPS as c, FILTER_CAST_BOOL as d, FILTER_CAST_NUMBER as e, FILTER_NO_CAST as f, TYPE_FLOW as g, TYPE_SECTION as h, TYPE_HEADING as i, TYPE_PHRASING as j, TYPE_EMBEDDED as k, TYPE_INTERACTIVE as l, TYPE_PALPABLE as m, FILTER_ALLOW as n, match as o };\n//# sourceMappingURL=bundle-94421b73.js.map\n",null,null,"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\nimport { F as Filter, A as ALLOWED_TAG_LIST, B as BANNED_TAG_LIST, a as ATTRIBUTES, b as FILTER_DENY, c as ATTRIBUTES_TO_PROPS, T as TAGS, E as Element, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, f as FILTER_NO_CAST } from './bundle-94421b73.js';\nexport { A as ALLOWED_TAG_LIST, a as ATTRIBUTES, c as ATTRIBUTES_TO_PROPS, B as BANNED_TAG_LIST, E as Element, n as FILTER_ALLOW, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, b as FILTER_DENY, f as FILTER_NO_CAST, F as Filter, M as Matcher, T as TAGS, k as TYPE_EMBEDDED, g as TYPE_FLOW, i as TYPE_HEADING, l as TYPE_INTERACTIVE, m as TYPE_PALPABLE, j as TYPE_PHRASING, h as TYPE_SECTION, o as match } from './bundle-94421b73.js';\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nclass StyleFilter extends Filter {\n  attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(key => {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return value;\n  }\n\n}\n/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nclass Parser {\n  constructor(markup, props = {}, matchers = [], filters = []) {\n    var _props$allowList;\n\n    _defineProperty(this, \"allowed\", void 0);\n\n    _defineProperty(this, \"banned\", void 0);\n\n    _defineProperty(this, \"blocked\", void 0);\n\n    _defineProperty(this, \"container\", void 0);\n\n    _defineProperty(this, \"content\", []);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"matchers\", void 0);\n\n    _defineProperty(this, \"filters\", void 0);\n\n    _defineProperty(this, \"keyIndex\", void 0);\n\n    if (process.env.NODE_ENV !== \"production\" && markup && typeof markup !== 'string') {\n      throw new TypeError('Interweave parser requires a valid string.');\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [...filters, new StyleFilter()];\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set((_props$allowList = props.allowList) !== null && _props$allowList !== void 0 ? _props$allowList : ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n\n  applyAttributeFilters(name, value) {\n    return this.filters.reduce((nextValue, filter) => nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue, value);\n  }\n  /**\n   * Loop through and apply all registered node filters.\n   */\n\n\n  applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce((nextNode, filter) => nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode, node);\n  }\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n\n\n  applyMatchers(string, parentConfig) {\n    const elements = {};\n    const {\n      props\n    } = this;\n    let matchedString = string;\n    let elementIndex = 0;\n    let parts = null;\n    this.matchers.forEach(matcher => {\n      const tagName = matcher.asTag().toLowerCase();\n      const config = this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n      if (props[matcher.inverseName] || !this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n\n      if (!this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n\n      let tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        const {\n          index,\n          length,\n          match,\n          valid,\n          void: isVoid,\n          ...partProps\n        } = parts;\n        const tokenName = matcher.propName + String(elementIndex); // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid ? `{{{${tokenName}/}}}` : `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n          this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: match,\n            matcher,\n            props: { ...props,\n              ...partProps,\n              key: this.keyIndex\n            }\n          };\n        } else {\n          tokenizedString += match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n\n\n  canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n\n\n  convertLineBreaks(markup) {\n    const {\n      noHtml,\n      disableLineBreaks\n    } = this.props;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n\n    let nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n\n\n  createContainer(markup) {\n    var _this$props$container;\n\n    const factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    const doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    const tag = (_this$props$container = this.props.containerTagName) !== null && _this$props$container !== void 0 ? _this$props$container : 'body';\n    const el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n\n\n  extractAttributes(node) {\n    const {\n      allowAttributes\n    } = this.props;\n    const attributes = {};\n    let count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    } // @ts-expect-error Cant type iterator\n\n\n    [...node.attributes].forEach(attr => {\n      const {\n        name,\n        value\n      } = attr;\n      const newName = name.toLowerCase();\n      const filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!this.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n\n      if (!newName.match(ALLOWED_ATTRS) && (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))) {\n        return;\n      } // Apply attribute filters\n\n\n      let newValue = newName === 'style' ? this.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n\n\n  extractStyleAttribute(node) {\n    const styles = {}; // eslint-disable-next-line unicorn/prefer-spread\n\n    Array.from(node.style).forEach(key => {\n      const value = node.style[key];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\n      }\n    });\n    return styles;\n  }\n  /**\n   * Return configuration for a specific tag.\n   */\n\n\n  getTagConfig(tagName) {\n    const common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return { ...common,\n        ...TAGS[tagName],\n        tagName\n      };\n    }\n\n    return common;\n  }\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n\n\n  isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      const href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href !== null && href !== void 0 && href.startsWith('#')) {\n        return true;\n      }\n\n      const protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n\n    return true;\n  }\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n\n\n  isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n\n\n  parse() {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n\n\n  parseNode(parentNode, parentConfig) {\n    const {\n      noHtml,\n      noHtmlExceptMatchers,\n      allowElements,\n      transform,\n      transformOnlyAllowList\n    } = this.props;\n    let content = [];\n    let mergedText = ''; // @ts-expect-error Cant type iterator\n\n    [...parentNode.childNodes].forEach(node => {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        const tagName = node.nodeName.toLowerCase();\n        const config = this.getTagConfig(tagName); // Persist any previous text\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n\n        const nextNode = this.applyNodeFilters(tagName, node);\n\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n\n        let children;\n\n        if (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n          this.keyIndex += 1;\n          const key = this.keyIndex; // Must occur after key is set\n\n          children = this.parseNode(nextNode, config);\n          const transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          }\n\n          if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n\n          this.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n\n        if (this.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && this.isTagAllowed(tagName) && (allowElements || this.canRenderChild(parentConfig, config))) {\n          var _children;\n\n          this.keyIndex += 1; // Build the props as it makes it easier to test\n\n          const attributes = this.extractAttributes(nextNode);\n          const elementProps = {\n            tagName\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push( /*#__PURE__*/React.createElement(Element, { ...elementProps,\n            key: this.keyIndex\n          }, (_children = children) !== null && _children !== void 0 ? _children : this.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = [...content, ...this.parseNode(nextNode, config.tagName ? config : parentConfig)];\n        } // Apply matchers if a text node\n\n      } else if (node.nodeType === TEXT_NODE) {\n        const text = noHtml && !noHtmlExceptMatchers ? node.textContent : // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = [...content, ...text];\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n\n\n  replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    const nodes = [];\n    let text = tokenizedString;\n    let open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      const [match, tokenName] = open;\n      const startIndex = open.index;\n      const isVoid = match.includes('/');\n\n      if (process.env.NODE_ENV !== \"production\" && !elements[tokenName]) {\n        throw new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n      } // Extract the previous non-token text\n\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n\n      const {\n        children,\n        matcher,\n        props: elementProps\n      } = elements[tokenName];\n      let endIndex; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = match.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        const close = text.match(new RegExp(`{{{/${tokenName}}}}`));\n\n        if (process.env.NODE_ENV !== \"production\" && !close) {\n          throw new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n        }\n\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(match.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  }\n\n}\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var _ref;\n\n  const {\n    attributes,\n    className,\n    containerTagName,\n    content,\n    emptyContent,\n    parsedContent,\n    tagName,\n    noWrap: baseNoWrap\n  } = props;\n  const tag = (_ref = containerTagName !== null && containerTagName !== void 0 ? containerTagName : tagName) !== null && _ref !== void 0 ? _ref : 'span';\n  const noWrap = tag === 'fragment' ? true : baseNoWrap;\n  let mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    const markup = new Parser(content !== null && content !== void 0 ? content : '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n/* eslint-disable promise/prefer-await-to-callbacks */\n\n\nfunction Interweave(props) {\n  const {\n    attributes,\n    className,\n    content = '',\n    disableFilters = false,\n    disableMatchers = false,\n    emptyContent = null,\n    filters = [],\n    matchers = [],\n    onAfterParse = null,\n    onBeforeParse = null,\n    tagName = 'span',\n    noWrap = false,\n    ...parserProps\n  } = props;\n  const allMatchers = disableMatchers ? [] : matchers;\n  const allFilters = disableFilters ? [] : filters;\n  const beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  const afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(matcher => {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  const markup = beforeCallbacks.reduce((string, callback) => {\n    const nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\" && typeof nextString !== 'string') {\n      throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n    }\n\n    return nextString;\n  }, content !== null && content !== void 0 ? content : ''); // Parse the markup\n\n  const parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  const nodes = afterCallbacks.reduce((parserNodes, callback) => {\n    const nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\" && !Array.isArray(nextNodes)) {\n      throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className // eslint-disable-next-line react/destructuring-assignment\n    ,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes,\n    tagName: tagName\n  });\n}\n\nexport { Interweave, Markup, Parser };\n//# sourceMappingURL=index.js.map\n",null,null,null,"/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n"],"sourceRoot":""}